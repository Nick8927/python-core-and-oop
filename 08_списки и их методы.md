# Методы списков в Python

## Теоретическая основа для собеседования

### 1. Основные свойства списков
- **Изменяемый** тип данных (mutable)
- **Упорядоченная** коллекция элементов
- **Динамический** размер (автоматическое расширение)
- **Гетерогенное** хранение (разные типы данных)

### 2. Классификация методов
- **Модифицирующие** - изменяют исходный список (sort, append, extend)
- **Информационные** - возвращают информацию (count, index)
- **Копирующие** - создают новые объекты (copy, sorted)

### 3. Сравнение с другими коллекциями
| Характеристика | Список | Кортеж | Множество |
|----------------|--------|--------|-----------|
| Изменяемость   | ✅ Да  | ❌ Нет | ✅ Да     |
| Упорядоченность| ✅ Да  | ✅ Да  | ❌ Нет    |
| Уникальность   | ❌ Нет | ❌ Нет | ✅ Да     |

## 1. Сортировка: sort() vs sorted()

### Метод sort() - in-place сортировка
```python
numbers = [3, 1, 4, 2]
numbers.sort()  # Изменяет исходный список
print(numbers)  # [1, 2, 3, 4]
```

### Функция sorted() - создание новой копии
```python
numbers = [3, 1, 4, 2]
sorted_numbers = sorted(numbers)  # Новый список
print(numbers)        # [3, 1, 4, 2] (оригинал не изменен)
print(sorted_numbers) # [1, 2, 3, 4]
```

**Ключевые различия:**

| Характеристика         | sort() | sorted() |
|------------------------|:------:|:--------:|
| Изменяет оригинал      | ✅ Да  | ❌ Нет   |
| Возвращает значение    | ❌ Нет | ✅ Да    |
| Работает с любыми итерируемыми | ❌ Нет | ✅ Да |
| Параметр `reverse`     | ✅ Да  | ✅ Да    |
| Параметр `key`         | ✅ Да  | ✅ Да    |

## 2. Добавление элементов

### Метод append() - добавление одного элемента
```python
fruits = ['apple', 'banana']
fruits.append('orange')
print(fruits)  # ['apple', 'banana', 'orange']
```

### Метод extend() - добавление нескольких элементов
```python
fruits = ['apple', 'banana']
fruits.extend(['orange', 'grape'])
print(fruits)  # ['apple', 'banana', 'orange', 'grape']
```

**Сравнение:**
```python
# append добавляет список как один элемент
fruits.append(['kiwi', 'mango'])  # ['apple', ['kiwi', 'mango']]

# extend добавляет элементы списка
fruits.extend(['kiwi', 'mango'])  # ['apple', 'kiwi', 'mango']
```

## 3. Удаление элементов

### Метод remove() - по значению
```python
numbers = [1, 2, 3, 2]
numbers.remove(2)  # Удаляет первое вхождение
print(numbers)     # [1, 3, 2]
```

### Метод pop() - по индексу
```python
numbers = [1, 2, 3]
last = numbers.pop()    # Удаляет и возвращает последний (3)
first = numbers.pop(0)  # Удаляет по индексу (1)
print(numbers)          # [2]
```

### Метод clear() - полная очистка
```python
numbers = [1, 2, 3]
numbers.clear()
print(numbers)  # []
```

## 4. Поиск и информация

### Метод count() - подсчет вхождений
```python
numbers = [1, 2, 2, 3, 2]
print(numbers.count(2))  # 3
```

### Метод index() - поиск позиции
```python
numbers = [10, 20, 30, 20]
print(numbers.index(20))       # 1 (первое вхождение)
print(numbers.index(20, 2))    # 3 (поиск с позиции 2)
```

## 5. Вставка и копирование

### Метод insert() - вставка по индексу
```python
numbers = [1, 2, 3]
numbers.insert(1, 99)  # Вставляет на позицию 1
print(numbers)         # [1, 99, 2, 3]
```

### Метод copy() - поверхностное копирование
```python
original = [1, 2, 3]
copied = original.copy()
print(id(original) != id(copied))  # True (разные объекты)
```

## Практические примеры

### Сортировка сложных структур
```python
users = [
    {'name': 'Alice', 'age': 25},
    {'name': 'Bob', 'age': 30},
    {'name': 'Charlie', 'age': 20}
]

users.sort(key=lambda x: x['age'])
print(users)  # Сортировка по возрасту
```

### Обработка пользовательского ввода
```python
numbers = []
while True:
    user_input = input("Введите число (или 'stop'): ")
    if user_input == 'stop':
        break
    numbers.append(int(user_input))

print(f"Вы ввели: {numbers}")
```

### Удаление дубликатов с сохранением порядка
```python
def remove_duplicates(lst):
    seen = set()
    result = []
    for item in lst:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result

numbers = [3, 1, 2, 1, 4, 3]
print(remove_duplicates(numbers))  # [3, 1, 2, 4]
```

## Вопросы для собеседования

1. **Чем отличается append() от extend()?**
   - append() добавляет один элемент, extend() добавляет элементы итерируемого объекта

2. **Когда использовать sort(), а когда sorted()?**
   - sort() когда нужно изменить оригинал, sorted() когда нужна новая копия

3. **Как сделать глубокую копию списка?**
   - import copy; copy.deepcopy(lst)

4. **Что вернет pop() без аргументов?**
   - Удалит и вернет последний элемент списка

5. **Как найти все вхождения элемента в списке?**
   - Через генератор: [i for i, x in enumerate(lst) if x == target]

6. **Как вставить элемент в начало списка?**
   - lst.insert(0, element) или lst = [element] + lst

7. **Чем опасен remove() для больших списков?**
   - Имеет сложность O(n) и сдвигает все элементы

8. **Как проверить, пуст ли список?**
   - if not lst: или if len(lst) == 0:

9. **Как объединить два списка?**
   - list1 + list2 или list1.extend(list2)

10. **Как развернуть список?**
    - lst.reverse() (in-place) или lst[::-1] (новая копия)
