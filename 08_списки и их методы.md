# Методы списков в Python

## Теоретическая основа для собеседования

### 1. Основные понятия
- **Список** - изменяемая упорядоченная коллекция элементов
- **Ключевые свойства**:
  - Поддержка индексации и срезов
  - Динамическое изменение размера
  - Хранение данных (разные типы)
  - Поддержка методов модификации

### 2. Когда использовать списки
- Для хранения изменяемых последовательностей
- Когда нужен частый доступ по индексу
- Для стековой структуры (append/pop)
- Для хранения коллекций с возможностью изменения

### 3. Сравнение с другими структурами
| Характеристика | Список | Кортеж | Множество |
|----------------|--------|--------|-----------|
| Изменяемость   | Да     | Нет    | Да        |
| Упорядоченность| Да     | Да     | Нет       |
| Уникальность   | Нет    | Нет    | Да        |

## 1. Сортировка: sort() vs sorted()

### Метод sort()
```python
nums = [3, 1, 4, 2]
nums.sort()  # Изменяет исходный список
print(nums)  # [1, 2, 3, 4]
```

### Функция sorted()
```python
nums = [3, 1, 4, 2]
new_nums = sorted(nums)  # Возвращает новый список
print(nums)      # [3, 1, 4, 2] (оригинал не изменен)
print(new_nums)  # [1, 2, 3, 4]
```

**Ключевые различия:**

| Характерика             | sort() | sorted() |
|-------------------------|:------:|:--------:|
| Изменяет оригинал       | Да     | Нет      |
| Возвращает значение     | Нет    | Да       |
| Работает с итерируемыми | Нет    | Да       |
| Параметр `reverse`      | Да     | Да       |

## 2. Добавление элементов

### Метод append()
```python
lst = [1, 2, 3]
lst.append(4)    # Добавляет один элемент
print(lst)       # [1, 2, 3, 4]
```

### Метод extend()
```python
lst = [1, 2]
lst.extend([3, 4])  # Добавляет элементы итерируемого объекта
print(lst)          # [1, 2, 3, 4]
```

## 3. Удаление элементов

### Метод remove()
```python
lst = [1, 2, 3, 2]
lst.remove(2)      # Удаляет первое вхождение значения
print(lst)         # [1, 3, 2]
```

### Метод pop()
```python
lst = [1, 2, 3]
last = lst.pop()    # Удаляет и возвращает последний элемент (3)
first = lst.pop(0)  # Удаляет элемент по индексу (1)
print(lst)          # [2]
```

## 4. Поиск и информация

### Метод count()
```python
lst = [1, 2, 2, 3]
print(lst.count(2))  # 2 (количество вхождений)
```

### Метод index()
```python
lst = [10, 20, 30]
print(lst.index(20))  # 1 (индекс первого вхождения)
```

## 5. Другие важные методы

### Метод insert()
```python
lst = [1, 2, 3]
lst.insert(1, 99)  # Вставляет 99 на позицию 1
print(lst)         # [1, 99, 2, 3]
```

### Метод clear()
```python
lst = [1, 2, 3]
lst.clear()       # Полностью очищает список
print(lst)        # []
```

### Метод copy()
```python
original = [1, 2, 3]
copied = original.copy()  # Создает поверхностную копию
print(id(original) != id(copied))  # True (разные объекты)
```

## 6. Практические примеры

### Комбинирование методов
```python
# Удаление дубликатов с сохранением порядка
lst = [3, 1, 2, 1, 4]
unique = []
for item in lst:
    if item not in unique:
        unique.append(item)
print(unique)  # [3, 1, 2, 4]
```

### Работа со вложенными списками
```python
matrix = [[1, 2], [3, 4]]
matrix[0].append(99)
print(matrix)  # [[1, 2, 99], [3, 4]]
```

## 7. Важные особенности

1. **Глубокая vs поверхностная копия:**
```python
import copy
lst = [[1, 2], [3, 4]]
shallow = lst.copy()       # Копирует только внешний список
deep = copy.deepcopy(lst)  # Полная рекурсивная копия
```

2. **Изменение во время итерации:**
```python
# Опасный код (может привести к ошибкам)
lst = [1, 2, 3, 4]
for item in lst:
    if item % 2 == 0:
        lst.remove(item)
```

3. **Эффективность операций:**
- `append()`/`pop()` - O(1)
- `insert(0)`/`pop(0)` - O(n)
- `x in lst` - O(n)

> **Совет:** Для частых операций с началом списка используйте `collections.deque`

## Вопросы для собеседования

1. **Чем отличается `sort()` от `sorted()`?**
   - `sort()` изменяет исходный список, `sorted()` возвращает новый
   - `sorted()` работает с любыми итерируемыми объектами

2. **Как эффективно добавить несколько элементов в список?**
   - Использовать `extend()` вместо нескольких `append()`
   - Или `+=` оператор: `lst += [4, 5, 6]`

3. **Как сделать глубокую копию списка?**
   - `copy.deepcopy()` для рекурсивного копирования вложенных структур

4. **Почему нельзя изменять список во время итерации?**
   - Это меняет индексы элементов и может привести к пропуску элементов или ошибкам

5. **Как проверить наличие элемента в списке?**
   - Оператором `in`, но для частых проверок лучше использовать множества (O(1) вместо O(n) быстрее работает) 

6. **Как удалить все элементы списка?**
   - `clear()` или присвоение среза `lst[:] = []`

7. **Когда использовать списки, а когда другие структуры?**
   - Списки - когда нужен порядок и изменяемость
   - Кортежи - для неизменяемых данных
   - Множества - для уникальных элементов

8. **Как работает выделение памяти для списков?**
   - Python выделяет память с запасом для оптимизации добавления элементов

9. **Как отсортировать список по сложному ключу?**
   - Использовать параметр `key` в `sort()`/`sorted()`:
   ```python
   lst.sort(key=lambda x: (x[1], x[0]))
   ```

10. **Как перевернуть список?**
    - `reverse()` метод или срез `lst[::-1]`

> **Pro tip:** Для работы со списками больших размеров используйте генераторы и `itertools` для оптимизации памяти.